{% extends "layout.html" %} {% block content %}
<h1 class="mb-1">Data Structure: Sorted Sets (ZSETs)</h1>
<p class="lead text-info">Use Case: A "Top 10" Popularity Leaderboard</p>
<hr class="my-4" />

<div class="row g-4">
  <div class="col-md-6">
    <div class="card bg-dark border-secondary h-100">
      <div class="card-body">
        <h5 class="card-title">Live Demo: Top 10 Most Queried Domains</h5>
        <p class="card-text">
          Every time you query a domain on the "Home" page (even a failed one!),
          its score in the leaderboard (key: <code>{{ leaderboard_key }}</code>)
          is incremented by 1.
        </p>

        {% if leaderboard %}
        <table class="table table-dark table-striped-columns mt-3">
          <thead>
            <tr>
              <th>Rank</th>
              <th>Domain</th>
              <th>Score (Queries)</th>
            </tr>
          </thead>
          <tbody>
            {% for domain, score in leaderboard %}
            <tr>
              <td><strong>#{{ loop.index }}</strong></td>
              <td><code>{{ domain }}</code></td>
              <td>{{ score|int }}</td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
        {% else %}
        <p class="text-secondary">No queries yet. Go query some domains!</p>
        {% endif %}
      </div>
    </div>
  </div>

  <div class="col-md-6">
    <div class="card bg-dark border-secondary h-100">
      <div class="card-body">
        <h5 class="card-title">Why Use a Redis Sorted Set?</h5>
        <p>
          We need to maintain a "Top 10" list. A normal List isn't good, because
          we'd have to find a domain, update its count, and re-sort the
          <em>entire list</em> on every query. That's extremely slow!
        </p>
        <p>
          A <strong>Sorted Set (ZSET)</strong> is the perfect data structure for
          this. It's a collection of unique members, where each member has an
          associated <strong>score</strong>. Redis automatically keeps the
          collection sorted by this score.
        </p>
        <ul class="list-unstyled">
          <li class="mb-2">
            <code class="text-danger">ZINCRBY</code>: Atomically
            <strong>Z</strong
            >-Set-<strong>INCR</strong>ement-<strong>BY</strong>. This one
            command finds a member, adds 1 to its score, and <em>instantly</em>
            re-positions it in the sorted set. This is an
            <strong>O(log N)</strong> operation, which is incredibly fast.
          </li>
          <li>
            <code class="text-danger">ZREVRANGE</code>: Gets a
            <strong>Z</strong>-Set-<strong>REV</strong>erse-<strong
              >RANGE</strong
            >
            (highest to lowest score). Getting the top 10 is an
            <strong>O(log N + M)</strong> operation (where M is 10), which is
            also extremely fast, no matter how many domains are in the set.
          </li>
        </ul>
      </div>
    </div>
  </div>

  <div class="col-12">
    <div class="card bg-dark border-secondary">
      <div class="card-body">
        <h5 class="card-title">Technical Deep Dive</h5>

        <ul class="nav nav-tabs" id="myTab" role="tablist">
          <li class="nav-item" role="presentation">
            <button
              class="nav-link active"
              id="python-tab"
              data-bs-toggle="tab"
              data-bs-target="#python-tab-pane"
              type="button"
            >
              Python (Flask)
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button
              class="nav-link"
              id="cli-tab"
              data-bs-toggle="tab"
              data-bs-target="#cli-tab-pane"
              type="button"
            >
              Try it in <code>redis-cli</code>
            </button>
          </li>
        </ul>
        <div class="tab-content mt-3" id="myTabContent">
          <div class="tab-pane fade show active" id="python-tab-pane">
            <p>
              On every DNS lookup (in the <code>home()</code> route), we run
              this one command:
            </p>
            <pre><code class="language-python" style="background: #2b2b2b; color: #f8f8f2; padding: 1em; display: block; border-radius: 5px;">
# Increment the score for 'domain_name' by 1 in the set 'dns:popularity'
r.zincrby(POPULARITY_KEY, 1, domain_name)
</code></pre>
            <p>To display the leaderboard on this page, we run:</p>
            <pre><code class="language-python" style="background: #2b2b2b; color: #f8f8f2; padding: 1em; display: block; border-radius: 5px;">
# Get ranks 0-9 (the top 10) in reverse order (highest score first)
# withscores=True returns ('member', score) tuples
leaderboard = r.zrevrange(POPULARITY_KEY, 0, 9, withscores=True)
</code></pre>
          </div>

          <div class="tab-pane fade" id="cli-tab-pane">
            <p>
              Open <code class="text-info">redis-cli</code> and query a few
              domains on the Home page. Then try these commands:
            </p>
            <pre><code style="background: #2b2b2b; color: #f8f8f2; padding: 1em; display: block; border-radius: 5px;">
# Get the Top 3 domains with their scores
ZREVRANGE dns:popularity 0 2 WITHSCORES

# Get the Top 3 domains (lowest scores)
ZRANGE dns:popularity 0 2 WITHSCORES

# Get the score for a single domain
ZSCORE dns:popularity "google.com"

# Add 100 to a domain's score yourself and refresh the page!
ZINCRBY dns:popularity 100 "google.com"

# See how many domains are in our leaderboard
ZCARD dns:popularity
</code></pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}
